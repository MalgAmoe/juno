"use strict";(self.webpackChunkjuno_docs=self.webpackChunkjuno_docs||[]).push([[1826],{3905:function(e,t,n){n.d(t,{Zo:function(){return p},kt:function(){return f}});var r=n(7294);function o(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function i(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);t&&(r=r.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,r)}return n}function a(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?i(Object(n),!0).forEach((function(t){o(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):i(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function c(e,t){if(null==e)return{};var n,r,o=function(e,t){if(null==e)return{};var n,r,o={},i=Object.keys(e);for(r=0;r<i.length;r++)n=i[r],t.indexOf(n)>=0||(o[n]=e[n]);return o}(e,t);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);for(r=0;r<i.length;r++)n=i[r],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(o[n]=e[n])}return o}var s=r.createContext({}),l=function(e){var t=r.useContext(s),n=t;return e&&(n="function"==typeof e?e(t):a(a({},t),e)),n},p=function(e){var t=l(e.components);return r.createElement(s.Provider,{value:t},e.children)},m={inlineCode:"code",wrapper:function(e){var t=e.children;return r.createElement(r.Fragment,{},t)}},u=r.forwardRef((function(e,t){var n=e.components,o=e.mdxType,i=e.originalType,s=e.parentName,p=c(e,["components","mdxType","originalType","parentName"]),u=l(n),f=o,h=u["".concat(s,".").concat(f)]||u[f]||m[f]||i;return n?r.createElement(h,a(a({ref:t},p),{},{components:n})):r.createElement(h,a({ref:t},p))}));function f(e,t){var n=arguments,o=t&&t.mdxType;if("string"==typeof e||o){var i=n.length,a=new Array(i);a[0]=u;var c={};for(var s in t)hasOwnProperty.call(t,s)&&(c[s]=t[s]);c.originalType=e,c.mdxType="string"==typeof e?e:o,a[1]=c;for(var l=2;l<i;l++)a[l]=n[l];return r.createElement.apply(null,a)}return r.createElement.apply(null,n)}u.displayName="MDXCreateElement"},379:function(e,t,n){n.r(t),n.d(t,{frontMatter:function(){return c},contentTitle:function(){return s},metadata:function(){return l},toc:function(){return p},default:function(){return u}});var r=n(7462),o=n(3366),i=(n(7294),n(3905)),a=["components"],c={title:"JSON-RPC Improving"},s=void 0,l={unversionedId:"future_implementations/jsonrpc-improving",id:"future_implementations/jsonrpc-improving",title:"JSON-RPC Improving",description:"Currently, we have an implementation of JSON-RPC for handle incoming connections in",source:"@site/docs/future_implementations/jsonrpc-improving.mdx",sourceDirName:"future_implementations",slug:"/future_implementations/jsonrpc-improving",permalink:"/docs/future_implementations/jsonrpc-improving",editUrl:"https://github.com/NethermindEth/juno/tree/main/docs/docs/future_implementations/jsonrpc-improving.mdx",tags:[],version:"current",frontMatter:{title:"JSON-RPC Improving"},sidebar:"tutorialSidebar",previous:{title:"Future Implementations",permalink:"/docs/category/future-implementations"},next:{title:"Layer 1 Integration",permalink:"/docs/future_implementations/l1-integration"}},p=[{value:"Benchmarking",id:"benchmarking",children:[],level:3}],m={toc:p};function u(e){var t=e.components,n=(0,o.Z)(e,a);return(0,i.kt)("wrapper",(0,r.Z)({},m,n,{components:t,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Currently, we have an implementation of JSON-RPC for handle incoming connections in\n",(0,i.kt)("a",{parentName:"p",href:"https://github.com/starkware-libs/starknet-specs"},"this form"),", and we want to test it to make sure we give the fastest\nimplementation possible."),(0,i.kt)("p",null,"Now, each time a request is made to the server, we use reflection to check if the server contains this method, and in\ncase it contains the method, start the check of each of the in/out params of the method."),(0,i.kt)("p",null,"After that we execute the method sending the params we already marshal to the in params of the method."),(0,i.kt)("p",null,"Each time the method is called, we need to make this computation."),(0,i.kt)("p",null,"Our proposal here, is to make this computation before start the RPC server and have a callback dictionary that contains\nall those methods pre-computed and saved in memory, so each time we ask, we will only need to check in the callback for\nresponse of each method, and params types will be loaded, without the need of create multiple times an object for the\nconnection to the rpc function."),(0,i.kt)("p",null,"Making this will allow us handle this hard problem to before the rpc start to handle connections."),(0,i.kt)("h3",{id:"benchmarking"},"Benchmarking"),(0,i.kt)("p",null,"Another point of view, is use something like\n",(0,i.kt)("a",{parentName:"p",href:"https://golangexample.com/golang-implementation-of-json-rpc-2-0-server-with-generics/"},"this")," to create a generic rpc\nwrapper for methods, and maybe, in case of possible, establish some constrains against params."))}u.isMDXComponent=!0}}]);